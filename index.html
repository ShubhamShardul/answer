<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Valentine ‚Äî Fixed, Playful & Robust</title>
<style>
  :root{ 
    --accent:#ff4d6d; 
    --accent-light:#ff8fa3;
    --accent-dark:#e63b5c;
    --success:#06d6a0;
    --bg1:#fff1f5; 
    --bg2:#ffe6eb; 
    --muted:#6e6e6e;
    --text:#1a1a1a;
    --text-light:#4a4a4a;
    --border:#f0f0f0;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Roboto,"Noto Sans",sans-serif;color:var(--text);}
  body{
    display:grid;
    place-items:center;
    padding:20px;
    background:linear-gradient(135deg,#fff1f5 0%,#ffe6eb 50%,#ffb3c1 100%);
    overflow:hidden;
    min-height:100vh;
  }
  
  .card{
    width:100%;
    max-width:480px;
    background:#fff;
    border-radius:24px;
    padding:40px;
    box-shadow:0 20px 60px rgba(255,77,109,0.2);
    text-align:center;
    position:relative;
    backdrop-filter:blur(10px);
    z-index:10;
  }
  
  h1{
    color:var(--accent);
    margin:12px 0 16px;
    font-size:28px;
    font-weight:800;
    letter-spacing:-0.5px;
    background:linear-gradient(135deg,var(--accent),var(--accent-light));
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
  }
  
  .sub{
    font-size:15px;
    color:var(--text-light);
    margin:0 0 28px;
    font-weight:500;
    line-height:1.6;
  }
  
  .row{
    display:flex;
    gap:14px;
    justify-content:center;
    align-items:center;
    margin-bottom:24px;
    flex-wrap:wrap;
  }
  
  button{
    padding:12px 20px;
    border-radius:14px;
    border:none;
    cursor:pointer;
    font-weight:700;
    font-size:14px;
    transition:all 0.3s cubic-bezier(0.34,1.56,0.64,1);
    box-shadow:0 4px 12px rgba(0,0,0,0.08);
    position:relative;
    overflow:hidden;
  }
  
  button:hover{
    transform:translateY(-2px);
    box-shadow:0 8px 20px rgba(0,0,0,0.12);
  }
  
  button:active{
    transform:translateY(0);
    box-shadow:0 2px 8px rgba(0,0,0,0.08);
  }
  
  .yes{
    background:linear-gradient(135deg,var(--accent),var(--accent-light));
    color:#fff;
    padding:14px 28px;
    font-size:16px;
    min-width:140px;
    flex:1;
    box-shadow:0 8px 24px rgba(255,77,109,0.3);
  }
  
  .yes:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    box-shadow: 0 4px 12px rgba(255,77,109,0.15);
  }
  
  .yes:disabled:hover {
    box-shadow: 0 4px 12px rgba(255,77,109,0.15);
    transform: none;
  }
  
  .no{
    background:#f8f8f8;
    color:var(--text);
    border:2px solid var(--border);
    transition:all 0.3s ease;
    flex:1;
    font-size:16px;
    padding:12px 24px;
  }
  
  .no:hover{
    background:#fff;
    border-color:var(--accent);
    color:var(--accent);
  }
  
  .control{
    background:#f0f0f0;
    border:none;
    padding:10px 14px;
    border-radius:12px;
    font-size:13px;
    font-weight:600;
    color:var(--text-light);
    transition:all 0.2s ease;
    cursor:pointer;
  }
  
  .control:hover{
    background:#e8e8e8;
  }
  
  .control:active{
    background:#ddd;
  }
  
  .chaos-container{
    background:linear-gradient(135deg,rgba(255,77,109,0.05),rgba(255,77,109,0.02));
    border-radius:16px;
    padding:16px 20px;
    margin:24px 0;
    display:flex;
    align-items:center;
    gap:14px;
  }
  
  .chaos-label{
    font-size:13px;
    font-weight:700;
    color:var(--text);
    min-width:50px;
  }
  
  input[type="range"]{
    width:100%;
    height:6px;
    -webkit-appearance:none;
    appearance:none;
    background:linear-gradient(to right,#ccc,var(--accent));
    border-radius:3px;
    outline:none;
    flex:1;
  }
  
  input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;
    appearance:none;
    width:20px;
    height:20px;
    border-radius:50%;
    background:linear-gradient(135deg,var(--accent),var(--accent-light));
    cursor:pointer;
    box-shadow:0 2px 8px rgba(255,77,109,0.3);
    transition:all 0.2s ease;
  }
  
  input[type="range"]::-webkit-slider-thumb:hover{
    transform:scale(1.2);
    box-shadow:0 4px 12px rgba(255,77,109,0.4);
  }
  
  input[type="range"]::-moz-range-thumb{
    width:20px;
    height:20px;
    border-radius:50%;
    background:linear-gradient(135deg,var(--accent),var(--accent-light));
    cursor:pointer;
    border:none;
    box-shadow:0 2px 8px rgba(255,77,109,0.3);
    transition:all 0.2s ease;
  }
  
  .reset-btn{
    font-size:13px;
    padding:10px 16px;
  }
  
  canvas#confetti{
    position:fixed;
    left:0;
    top:0;
    width:100%;
    height:100%;
    pointer-events:none;
    z-index:5;
  }
  
  .heart{
    position:fixed;
    pointer-events:none;
    font-size:24px;
    z-index:6;
    animation:floatUp 4s linear;
    filter:drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    animation-delay: var(--delay, 0s);
  }
  
  @keyframes floatUp { 
    0%{transform:translateY(100vh) scale(1) rotateZ(0deg);opacity:1}
    50%{opacity:1}
    100%{transform:translateY(-20vh) scale(0.5) rotateZ(360deg);opacity:0}
  }
  
  @keyframes bounce {
    0%, 100% { transform:scale(1) }
    50% { transform:scale(1.1) }
  }
  
  @keyframes shimmer {
    0%{box-shadow:0 0 0 0 rgba(255,77,109,0.4)}
    100%{box-shadow:0 0 0 10px rgba(255,77,109,0)}
  }
  
  .overlay{
    position:fixed;
    inset:0;
    display:none;
    place-items:center;
    background:rgba(0,0,0,0.45);
    backdrop-filter:blur(4px);
    z-index:40;
    animation:fadeIn 0.2s ease;
  }
  
  @keyframes fadeIn {
    from{opacity:0;backdrop-filter:blur(0)}
    to{opacity:1;backdrop-filter:blur(4px)}
  }
  
  .modal{
    background:#fff;
    padding:32px;
    border-radius:20px;
    max-width:520px;
    width:92%;
    box-shadow:0 20px 60px rgba(0,0,0,0.2);
    animation:slideUp 0.3s cubic-bezier(0.34,1.56,0.64,1);
  }
  
  @keyframes slideUp {
    from{transform:translateY(40px);opacity:0}
    to{transform:translateY(0);opacity:1}
  }
  
  .tiny-muted{
    font-size:12px;
    color:var(--muted);
    margin-top:16px;
    font-weight:500;
  }
  
  .clone{
    position:fixed;
    z-index:30;
    cursor:pointer;
    padding:10px 16px;
    border-radius:14px;
    border:2px solid var(--accent);
    background:linear-gradient(135deg,#fff,#fafafa);
    font-weight:800;
    font-size:14px;
    box-shadow:0 8px 20px rgba(255,77,109,0.25);
    transition:all 0.2s ease;
    color:var(--accent);
    animation:pulse 2s infinite;
  }
  
  .clone:hover{
    transform:scale(1.05);
    box-shadow:0 12px 28px rgba(255,77,109,0.35);
  }
  
  @keyframes pulse {
    0%, 100%{opacity:1}
    50%{opacity:0.7}
  }
  
  svg{
    transition:transform 0.15s cubic-bezier(0.34,1.56,0.64,1);
    filter:drop-shadow(0 4px 12px rgba(255,77,109,0.15));
  }
  
  @media (max-width:480px){ 
    .card{
      padding:28px 20px;
      border-radius:20px;
    }
    h1{font-size:24px;}
    .row{gap:10px}
    button{padding:12px 16px;font-size:15px}
    .chaos-container{flex-wrap:wrap}
  }
</style>
</head>
<body>
  <canvas id="confetti"></canvas>

  <main class="card" role="application" aria-labelledby="q">
    <h1 id="q">Will you be my Valentine? ‚ù§Ô∏è</h1>
    <p class="sub">Click Yes if you mean it. Click No to witness mischief.</p>

    <div class="row" style="margin-bottom:12px">
      <button id="yesBtn" class="yes" aria-label="Yes">Yes üíò</button>
      <button id="noBtn" class="no" aria-label="No">No üôà</button>
    </div>


  </main>

  <!-- Cat modal (positioned, not full-screen overlay) -->
  <div id="catContainer" style="position:fixed;bottom:30px;right:30px;display:none;z-index:35;pointer-events:auto;animation:slideInRight 0.4s cubic-bezier(0.34,1.56,0.64,1);">
    <style>
      @keyframes slideInRight {
        from{transform:translateX(120px);opacity:0}
        to{transform:translateX(0);opacity:1}
      }
      @keyframes popIn {
        0%{transform:scale(0.8);opacity:0}
        100%{transform:scale(1);opacity:1}
      }
    </style>
    <div style="background:linear-gradient(135deg,#fff,#fafafa);border-radius:20px;padding:24px;box-shadow:0 16px 48px rgba(255,77,109,0.25);text-align:center;min-width:220px;border:2px solid rgba(255,77,109,0.1);animation:popIn 0.3s cubic-bezier(0.34,1.56,0.64,1);">
      <svg viewBox="0 0 120 120" style="width:110px;height:110px;margin:0 auto;display:block;filter:drop-shadow(0 4px 12px rgba(255,77,109,0.2))">
        <g transform="translate(10,10)">
          <ellipse cx="50" cy="60" rx="34" ry="30" fill="#ffd6e0"/>
          <ellipse cx="30" cy="36" rx="8" ry="10" fill="#ffd6e0"/>
          <ellipse cx="70" cy="36" rx="8" ry="10" fill="#ffd6e0"/>
          <circle cx="40" cy="58" r="4" fill="#333"/><circle cx="60" cy="58" r="4" fill="#333"/>
          <path d="M45 72 Q50 78 55 72" stroke="#cc4d6d" stroke-width="2" fill="none" stroke-linecap="round"/>
        </g>
      </svg>
      <div style="font-weight:800;margin-top:14px;font-size:15px;color:#1a1a1a">I brought treats! üê±</div>
      <div style="height:12px"></div>
      <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
        <button id="catCuddle" class="yes" style="padding:10px 14px;font-size:13px;flex:1;min-width:100px">Cuddle üíï</button>
        <button id="catPoke" class="control" style="padding:10px 14px;font-size:13px;flex:1;min-width:80px;background:linear-gradient(135deg,rgba(255,77,109,0.1),rgba(255,77,109,0.05));color:var(--accent);font-weight:700">Poke üëâ</button>
        <button id="catClose" class="control" style="padding:10px 14px;font-size:13px;flex:1;min-width:70px">Close ‚úï</button>
      </div>
    </div>
  </div>

<script>
/* === Robust, corrected logic ===
   Goals fixed:
   - No button moves but never disappears (kept inside viewport)
   - Yes click is idempotent (only triggers acceptance once)
   - catPoke has cooldown, spawns a single yes-clone (no repeated auto-Yes)
   - spawnYesClone limit and cleanup implemented
   - single confetti system with safe RAF
   - all intervals/timeouts tracked and cleared on reset
   - keyboard shortcuts work
*/

/* ---------- Utilities ---------- */
const $ = sel => document.querySelector(sel);
const rand = (a,b) => a + Math.random() * (b - a);
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
function now() { return Date.now(); }

/* ---------- Elements ---------- */
const yesBtn = $('#yesBtn'), noBtn = $('#noBtn');
const catContainer = $('#catContainer'), catCuddle = $('#catCuddle'), catPoke = $('#catPoke'), catClose = $('#catClose');
const confettiCanvas = document.getElementById('confetti'), qEl = $('#q');
const subtitle = document.querySelector('.sub');

// Safety check: ensure critical elements exist
if (!yesBtn || !noBtn || !qEl || !subtitle || !confettiCanvas) {
  console.error('Critical DOM elements missing. App may not work.');
}

/* ---------- State ---------- */
const STATE = {
  accepted: false,
  attempts: 0,
  chaos: 7,
  lastPokeAt: 0,
  clonesActive: 0,
  yesBtnClicked: false // debounce flag for yes button
};

const CONFIG = {
  MAX_CLONES: 3,
  CLONE_TTL_MS: 9000,
  POKE_COOLDOWN_MS: 2000
};

/* track timers/intervals so we can clear them */
const TIMERS = new Set();

/* Track cat button listeners for cleanup */
let catButtonListeners = {
  cuddle: null,
  poke: null,
  close: null
};

/* ---------- Audio (gesture-friendly) ---------- */
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e) {
      console.warn('Audio context creation failed:', e);
      return false;
    }
  }
  // Only resume if suspended, don't force if running
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }
  return audioCtx.state === 'running' || audioCtx.state === 'interrupted';
}
function playTone(freq=660, dur=0.12, type='sine', vol=0.12) {
  try {
    if (!ensureAudio()) return; // Single call, check result
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(vol, audioCtx.currentTime);
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    // stop later
    const stopId = setTimeout(() => { 
      try { 
        o.stop();
        o.disconnect();
        g.disconnect();
      } catch(e){} 
    }, (dur + 0.05) * 1000);
    TIMERS.add(stopId);
  } catch(e){}
}
function boing(){ playTone(660,0.14,'sine',0.12); playTone(880,0.08,'sine',0.06); }
function pop(){ playTone(760,0.06,'square',0.14); }
function tada(){ playTone(880,0.14,'sine',0.12); playTone(660,0.18,'sine',0.12); }

/* ---------- Confetti (single, robust) ---------- */
const ctx = confettiCanvas ? (confettiCanvas.getContext ? confettiCanvas.getContext('2d') : null) : null;
let confettiPieces = [], confettiRaf = null;
function resizeCanvas(){ 
  if (!confettiCanvas) return; // Safety check
  confettiCanvas.width = window.innerWidth; 
  confettiCanvas.height = window.innerHeight;
  // Clear confetti pieces when resizing to prevent clipping artifacts
  confettiPieces = [];
}
if (confettiCanvas) {
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
}

function spawnConfetti(count=60){
  if (!ctx || !confettiCanvas) return; // Safety check
  // Ensure canvas is properly sized
  if (confettiCanvas.width <= 0 || confettiCanvas.height <= 0) {
    resizeCanvas();
  }
  for (let i=0;i<count;i++){
    confettiPieces.push({
      x: Math.random() * confettiCanvas.width,
      y: -10 - Math.random()*200,
      w: 6 + Math.random()*10,
      h: 8 + Math.random()*10,
      vx: rand(-3,3),
      vy: rand(2,6),
      rot: Math.random()*360,
      vr: rand(-6,6),
      color: ['#ff4d6d','#ffd166','#06d6a0','#118ab2','#bd7efc'][i % 5],
      life: 0
    });
  }
  if (!confettiRaf) confettiRaf = requestAnimationFrame(tickConfetti);
}
function tickConfetti(){
  if (!ctx || !confettiCanvas) return; // Safety check
  ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
  if (!Array.isArray(confettiPieces)) confettiPieces = []; // Validate array
  for (const p of confettiPieces){
    p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.rot += p.vr; p.life ++;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot * Math.PI/180);
    ctx.fillStyle = p.color;
    ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
    ctx.restore();
  }
  // garbage collect off-screen
  confettiPieces = confettiPieces.filter(p => p.y < confettiCanvas.height + 100);
  if (confettiPieces.length) confettiRaf = requestAnimationFrame(tickConfetti);
  else { cancelAnimationFrame(confettiRaf || 0); confettiRaf = null; ctx && ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height); }
}

/* ---------- Hearts / emoji ---------- */
function launchHearts(rate=30){
  const burst = Math.max(6, Math.floor(rate/3) + Math.floor(Math.random()*rate/4));
  for (let i=0;i<burst;i++){
    const el = document.createElement('div');
    el.className = 'heart';
    el.style.left = (Math.random()*92) + 'vw';
    el.style.fontSize = (14 + Math.random()*32) + 'px';
    el.textContent = Math.random() > 0.6 ? 'üíñ' : '‚ù§Ô∏è';
    el.style.setProperty('--delay', (i * 0.05) + 's');
    // Ensure element is in DOM before accessing and document.body exists
    if (document.body) {
      try {
        document.body.appendChild(el);
      } catch(e) {
        console.error('Failed to append heart:', e);
      }
    }
    const t = setTimeout(()=> {
      try {
        el.style.opacity = '0';
        const removeT = setTimeout(() => {
          try { el.remove(); } catch(e){}
        }, 300);
        TIMERS.add(removeT);
      } catch(e){}
    }, 4200 + Math.random()*1500);
    TIMERS.add(t);
  }
}

/* ---------- spawnYesClone (chasing clone) ---------- */
let clonesCount = 0;
const cloneListeners = new Map(); // track listeners per clone
function spawnYesClone() {
  if (STATE.accepted) return;
  if (clonesCount >= CONFIG.MAX_CLONES) return; // limit clones
  clonesCount++;
  STATE.clonesActive = clonesCount;

  const c = document.createElement('button');
  c.className = 'clone';
  c.textContent = 'Yes! üòç';
  let cloneClicked = false; // debounce flag
  // initial position - ensure within safe viewport
  const pad = 20;
  const cloneBtnW = 80;
  const cloneBtnH = 40;
  const maxLeft = Math.max(pad, window.innerWidth - cloneBtnW - pad);
  const maxTop = Math.max(pad, window.innerHeight - cloneBtnH - pad);
  let left = Math.max(pad, Math.min(Math.random()*(window.innerWidth - cloneBtnW), maxLeft));
  let top = Math.max(pad, Math.min(Math.random()*(window.innerHeight - cloneBtnH), maxTop));
  c.style.left = left + 'px';
  c.style.top = top + 'px';
  c.style.padding = '8px 12px';
  document.body.appendChild(c);

  // chase behavior
  function chase(e){
    try {
      // Guard: check if clone still exists in DOM
      if (!document.body.contains(c)) {
        cleanupChaseListener();
        return;
      }
      const r = c.getBoundingClientRect();
      if (!r) return; // BoundingClientRect unavailable
      const dx = e.clientX !== undefined ? e.clientX : (e.touches?.[0]?.clientX || 0);
      const dy = e.clientY !== undefined ? e.clientY : (e.touches?.[0]?.clientY || 0);
      c.style.left = (r.left + (dx - r.left - r.width/2)*0.12) + 'px';
      c.style.top = (r.top + (dy - r.top - r.height/2)*0.12) + 'px';
    } catch(e){}
  }
  
  // Cleanup function for chase listeners
  function cleanupChaseListener() {
    window.removeEventListener('mousemove', chase);
    window.removeEventListener('touchmove', chase);
    window.removeEventListener('mouseup', onChaseEnd);
    window.removeEventListener('touchend', onChaseEnd);
  }
  
  // Stop chasing on mouse/touch up
  function onChaseEnd() {
    cleanupChaseListener();
  }
  
  window.addEventListener('mousemove', chase);
  window.addEventListener('touchmove', chase);
  window.addEventListener('mouseup', onChaseEnd);
  window.addEventListener('touchend', onChaseEnd);
  cloneListeners.set(c, { chase, cleanupChaseListener, onChaseEnd });

  // clicking clone triggers accept() once and removes clone
  const onCloneClick = () => {
    if (cloneClicked) return; // Prevent multiple clicks
    cloneClicked = true;
    try {
      c.remove();
      const listenerObj = cloneListeners.get(c);
      if (listenerObj && listenerObj.cleanupChaseListener) {
        listenerObj.cleanupChaseListener();
      }
      cloneListeners.delete(c);
    } catch(e){}
    clonesCount = Math.max(0, clonesCount-1);
    STATE.clonesActive = clonesCount;
    accept();
  };
  c.addEventListener('click', onCloneClick);

  // auto-remove after TTL
  const ttl = setTimeout(()=> {
    if (cloneClicked) return; // Already removed by click
    cloneClicked = true;
    try { 
      c.remove();
      const listener = cloneListeners.get(c);
      if (listener) window.removeEventListener('mousemove', listener);
      cloneListeners.delete(c);
    } catch(e){}
    clonesCount = Math.max(0, clonesCount-1);
    STATE.clonesActive = clonesCount;
  }, CONFIG.CLONE_TTL_MS);
  TIMERS.add(ttl);
}

/* Move No button safely (keeps it visible, avoids card) */
function moveNoButtonRandomly() {
  if (!noBtn) return; // Safety check
  const pad = 20; // larger safety pad
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  
  // Get actual button dimensions from element
  let btnW = 100;
  let btnH = 44;
  try {
    const rect = noBtn.getBoundingClientRect();
    btnW = Math.max(80, rect.width || 100);
    btnH = Math.max(40, rect.height || 44);
  } catch(e) {}
  
  // Get card bounds to avoid overlap (accounting for viewport positioning)
  const card = document.querySelector('.card');
  let cardRect = null;
  if (card) {
    cardRect = card.getBoundingClientRect();
  }
  
  // On mobile, constrain to safe area (avoid keyboard, edges)
  const isMobile = vw < 600;
  const safeBottom = isMobile ? 100 : 60; // extra space on mobile for keyboard
  
  // ensure we have room
  if (vw < btnW + pad*2 || vh < btnH + pad*2 + safeBottom) {
    // Fallback: position in bottom-left corner
    noBtn.style.position = 'fixed';
    noBtn.style.left = pad + 'px';
    noBtn.style.top = (vh - btnH - pad - safeBottom) + 'px';
    noBtn.style.transform = '';
    noBtn.style.pointerEvents = 'auto';
    noBtn.style.display = 'block';
    noBtn.style.visibility = 'visible';
    return;
  }
  
  // Try random positions until we find one that doesn't overlap card
  let attempts = 0;
  let left, top;
  let foundGood = false;
  
  while (attempts < 20 && !foundGood) {
    left = Math.random() * (vw - btnW - pad*2) + pad;
    top = Math.random() * (vh - btnH - pad*2 - safeBottom) + pad;
    
    // extra safety clamp
    left = clamp(left, pad, vw - btnW - pad);
    top  = clamp(top, pad, vh - btnH - pad - safeBottom);
    
    // Check if position overlaps card (viewport coordinates already account for scroll)
    if (cardRect) {
      const btnRight = left + btnW;
      const btnBottom = top + btnH;
      const overlap = !(btnRight < cardRect.left - 20 || 
                       left > cardRect.right + 20 || 
                       btnBottom < cardRect.top - 20 || 
                       top > cardRect.bottom + 20);
      if (!overlap) foundGood = true;
    } else {
      foundGood = true;
    }
    attempts++;
  }
  
  noBtn.style.position = 'fixed';
  noBtn.style.left = left + 'px';
  noBtn.style.top = top + 'px';
  noBtn.style.transform = '';
  noBtn.style.pointerEvents = 'auto';
  noBtn.style.display = 'block'; // ensure it's visible
  noBtn.style.visibility = 'visible'; // ensure it's not hidden
}

/* ---------- accept() idempotent ---------- */
function accept() {
  if (STATE.accepted || STATE.yesBtnClicked) return; // Prevent multiple accepts
  STATE.yesBtnClicked = true;
  STATE.accepted = true;
  
  // Disable yes button immediately to prevent clicks
  if (yesBtn) {
    yesBtn.disabled = true;
  }
  
  // Hide cat immediately
  hideCat();
  
  if (subtitle) {
    subtitle.textContent = 'YAY!! You said YES üíñ';
    subtitle.style.animation = 'none';
    subtitle.style.opacity = '1'; // Ensure visible
    setTimeout(() => {
      if (subtitle) subtitle.style.animation = 'bounce 0.6s cubic-bezier(0.34,1.56,0.64,1)';
    }, 10);
  }
  
  // visual + audio reward
  try { 
    if (ensureAudio()) {} // Check if audio started
  } catch(e){}
  tada();
  spawnConfetti(140);
  launchHearts(120);
  
  // Animate main heading
  if (qEl) {
    qEl.textContent = 'Will you be my Valentine? ‚ù§Ô∏è'; // Reset text first
    qEl.style.animation = 'none';
    qEl.style.opacity = '1'; // Ensure visible
    setTimeout(() => {
      if (qEl) qEl.style.animation = 'bounce 0.8s cubic-bezier(0.34,1.56,0.64,1)';
    }, 10);
  }
  
  // hide No button after a brief moment (explicit acceptance)
  if (noBtn) {
    setTimeout(()=> {
      try { 
        noBtn.style.opacity = '0';
        noBtn.style.transform = 'scale(0.9)';
        setTimeout(() => {
          if (noBtn) noBtn.style.display = 'none';
        }, 300);
      } catch(e){}
    }, 400);
  }
  
  // clear clones and their listeners
  document.querySelectorAll('.clone').forEach(n=> {
    const listener = cloneListeners.get(n);
    if (listener) {
      window.removeEventListener('mousemove', listener);
      window.removeEventListener('touchmove', listener);
    }
    cloneListeners.delete(n);
    n.style.opacity = '0';
    setTimeout(() => {
      try { n.remove(); } catch(e){}
    }, 200);
  });
  clonesCount = 0; STATE.clonesActive = 0;
}

/* ---------- catPoke: single controlled reaction ---------- */
function catPokeHandler() {
  if (!catContainer) return; // Safety check
  const nowTs = now();
  if (nowTs - STATE.lastPokeAt < CONFIG.POKE_COOLDOWN_MS) {
    // ignore rapid repeated pokes (cooldown)
    pop();
    return;
  }
  STATE.lastPokeAt = nowTs;
  
  // Poke animation feedback
  pop();
  const catSvg = catContainer.querySelector('svg');
  if (catSvg) {
    catSvg.style.transform = 'scale(0.95) rotate(-5deg)';
    setTimeout(() => {
      if (catSvg && catSvg.style) catSvg.style.transform = 'scale(1) rotate(0deg)';
    }, 150);
  }
  
  // Spawn yes clone
  spawnYesClone();
}

/* ---------- Misbehavior when clicking/hovering No ---------- */
function onNoInteracted() {
  if (STATE.accepted || !noBtn) return; // Safety check
  STATE.attempts++;
  // Just move the button - no pranks, no clones
  moveNoButtonRandomly();
  // Optional: soft sound feedback
  if (Math.random() < 0.3) boing();
}

/* spinner prank (clean) */
let spinnerTimer = null;
let spinnerOverlay = null;
function showSpinnerPrank() {
  // prevent multiple spinners - clean up old one first
  if (spinnerOverlay) {
    try { spinnerOverlay.remove(); } catch(e){}
    spinnerOverlay = null;
  }
  clearTimeout(spinnerTimer);
  
  spinnerOverlay = document.createElement('div');
  spinnerOverlay.className = 'overlay';
  spinnerOverlay.style.display = 'grid';
  spinnerOverlay.setAttribute('aria-hidden','false');
  spinnerOverlay.innerHTML = `<div class="modal" role="dialog" aria-modal="true" style="text-align:center">
    <div style="font-weight:800;margin-bottom:8px">Processing your answer...</div>
    <div style="height:8px"></div><div style="font-size:12px;color:#666">Please wait...</div>
  </div>`;
  
  if (document.body) {
    try {
      document.body.appendChild(spinnerOverlay);
    } catch(e) {
      console.error('Failed to append spinner:', e);
      return;
    }
  }

  spinnerTimer = setTimeout(()=> {
    // flip to ERROR & remove
    if (spinnerOverlay && spinnerOverlay.parentNode) {
      try { 
        spinnerOverlay.querySelector('.modal').innerHTML = `<div style="font-weight:900;color:#c94">ERROR: You meant YES ‚Äî retrying...</div>`; 
      } catch(e){}
      pop();
      setTimeout(()=> { 
        try { if (spinnerOverlay && spinnerOverlay.parentNode) spinnerOverlay.remove(); } catch(e){}
        spinnerOverlay = null;
      }, 820);
    }
  }, 900 + Math.random()*900);
  TIMERS.add(spinnerTimer);
}

/* showCat (shows cat in corner) */
function showCat() {
  if (!catContainer || STATE.accepted) return;
  const catSvg = catContainer.querySelector('svg');
  if (catSvg && catSvg.style) catSvg.style.transform = 'scale(1) rotate(0deg)'; // Reset SVG state
  catContainer.style.display = 'block';
  boing();
}

/* hideCat (hides cat) */
function hideCat() {
  if (!catContainer) return;
  const catSvg = catContainer.querySelector('svg');
  if (catSvg && catSvg.style) catSvg.style.transform = 'scale(1) rotate(0deg)'; // Reset SVG state
  catContainer.style.display = 'none';
}

/* ---------- Reset / cleanup ---------- */
function clearAllTimers() {
  for (const t of TIMERS) {
    try { clearTimeout(t); } catch(e){}
  }
  TIMERS.clear();
}
function resetAll() {
  // clear timers
  clearAllTimers();
  
  // Remove old keyboard listeners to prevent accumulation
  removeKeyboardListeners();
  
  // Remove cat button listeners to prevent accumulation
  if (catCuddle && catButtonListeners.cuddle) {
    catCuddle.removeEventListener('click', catButtonListeners.cuddle);
  }
  if (catPoke && catButtonListeners.poke) {
    catPoke.removeEventListener('click', catButtonListeners.poke);
  }
  if (catClose && catButtonListeners.close) {
    catClose.removeEventListener('click', catButtonListeners.close);
  }
  
  // clear spinner overlay reference
  if (spinnerOverlay) {
    try { spinnerOverlay.remove(); } catch(e){}
    spinnerOverlay = null;
  }
  
  // cancel confetti RAF
  try { if (confettiRaf) cancelAnimationFrame(confettiRaf); } catch(e){}
  confettiRaf = null; confettiPieces = []; ctx && ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
  
  // remove clones and clean up their listeners
  document.querySelectorAll('.clone').forEach(n => {
    const listener = cloneListeners.get(n);
    if (listener) {
      window.removeEventListener('mousemove', listener);
      window.removeEventListener('touchmove', listener);
    }
    cloneListeners.delete(n);
    n.remove();
  });
  
  // remove hearts
  document.querySelectorAll('.heart').forEach(n => n.remove());
  
  // hide cat
  hideCat();
  if (catContainer) {
    const catSvg = catContainer.querySelector('svg');
    if (catSvg && catSvg.style) catSvg.style.transform = 'scale(1) rotate(0deg)'; // Reset SVG state
  }
  
  // restore noBtn with smooth animation
  if (noBtn) {
    noBtn.style.display = '';
    noBtn.style.position = 'relative';
    noBtn.style.left = ''; 
    noBtn.style.top = ''; 
    noBtn.style.transform = '';
    noBtn.style.opacity = '1';
  }
  
  // reset state
  STATE.accepted = false;
  STATE.yesBtnClicked = false; // reset debounce flag
  STATE.attempts = 0;
  STATE.lastPokeAt = 0;
  STATE.clonesActive = 0;
  clonesCount = 0;
  if (qEl) {
    qEl.textContent = 'Will you be my Valentine? ‚ù§Ô∏è';
    qEl.style.animation = 'none';
    qEl.style.transform = '';
    qEl.style.opacity = '1'; // Ensure visible
  }
  if (subtitle) {
    subtitle.textContent = 'Click Yes if you mean it. Click No to witness mischief.';
    subtitle.style.animation = 'none';
    subtitle.style.opacity = '1';
    subtitle.style.transform = '';
  }
  
  // stop audio context if present (do not "close" ‚Äî just suspend)
  try { 
    if (audioCtx && audioCtx.state === 'running') {
      audioCtx.suspend().catch(()=>{});
    }
  } catch(e){}
  
  // Re-attach keyboard listeners
  attachKeyboardListeners();
  
  // Re-attach cat button listeners
  if (catCuddle && catButtonListeners.cuddle) {
    catCuddle.addEventListener('click', catButtonListeners.cuddle);
  }
  if (catPoke && catButtonListeners.poke) {
    catPoke.addEventListener('click', catButtonListeners.poke);
  }
  if (catClose && catButtonListeners.close) {
    catClose.addEventListener('click', catButtonListeners.close);
  }
  
  // Re-enable yes button
  if (yesBtn) {
    yesBtn.disabled = false;
  }
}

/* ---------- Event wiring ---------- */
/* No button: hover & click */
if (noBtn) {
  noBtn.addEventListener('mouseover', onNoInteracted);
  noBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    onNoInteracted();
  });
}

/* Yes button: idempotent accept */
if (yesBtn) {
  yesBtn.addEventListener('click', () => {
    accept();
  });
}

/* Cat actions - tracked for cleanup */
if (catCuddle) {
  catButtonListeners.cuddle = () => {
    hideCat(); 
    accept();
  };
  catCuddle.addEventListener('click', catButtonListeners.cuddle);
}
if (catPoke) {
  catButtonListeners.poke = () => {
    catPokeHandler();
  };
  catPoke.addEventListener('click', catButtonListeners.poke);
}
if (catClose) {
  catButtonListeners.close = () => {
    hideCat();
  };
  catClose.addEventListener('click', catButtonListeners.close);
}

/* keyboard shortcuts */
let keydownHandler = null;
function attachKeyboardListeners() {
  if (keydownHandler) {
    // Remove old handler if it exists
    document.removeEventListener('keydown', keydownHandler);
  }
  keydownHandler = (ev) => {
    const k = ev.key.toLowerCase();
    
    // Escape always resets (even after accepted)
    if (k === 'escape') {
      resetAll();
      return;
    }
    
    // Block Y/N after acceptance, but allow M (cat)
    if (STATE.accepted) {
      if (k === 'm') showCat?.();
      return;
    }
    
    // Normal shortcuts before acceptance
    if (k === 'y') yesBtn?.click?.();
    if (k === 'n') noBtn?.click?.();
    if (k === 'm') showCat?.();
  };
  document.addEventListener('keydown', keydownHandler);
}
function removeKeyboardListeners() {
  if (keydownHandler) {
    document.removeEventListener('keydown', keydownHandler);
    keydownHandler = null;
  }
}
// Attach on initialization
attachKeyboardListeners();

/* initial friendly nudge - only after DOM fully ready */
function launchInitialHearts() {
  try { 
    if (document.body && launchHearts) {
      launchHearts(18);
    }
  } catch(e){ 
    console.error('Initial hearts error:', e); 
  }
}
// Use Promise-based check for max compatibility
Promise.resolve().then(() => {
  if (document.readyState !== 'complete') {
    const handler = () => {
      launchInitialHearts();
      document.removeEventListener('DOMContentLoaded', handler);
    };
    document.addEventListener('DOMContentLoaded', handler);
  } else {
    setTimeout(launchInitialHearts, 600);
  }
});

/* ---------- Testing helpers exposed to console (safe) ---------- */
window.__VAL_FIX = {
  STATE,
  spawnYesClone,
  spawnConfetti,
  launchHearts,
  resetAll
};

/* End of script */
</script>
</body>
</html>
